[{"categories":null,"content":"I found myself wondering about unix sockets while working on Sozu, a reverse proxy written in Rust. A bunch of Sōzu issues led me to dig into Sōzu channels, which themselves make use of Metal I/O ’s implementation of unix sockets. Here the questions, summed up: what is a unix socket? how can we create one in Rust? how do we use it to stream data? So here we go. ","date":"2022-01-06","objectID":"/2022/whatsaunixsocket/:0:0","tags":null,"title":"Unix sockets, the basics in Rust","uri":"/2022/whatsaunixsocket/"},{"categories":null,"content":"What is a unix socket? It is not a web socket like 127.0.0.1:8080. You may have heard that in unix, everything is a file. Unix sockets seem to be a good example of this principle. They are empty files of sorts, only there to be written onto, and read from. Sockets seem to be a core feature of unix. In fact, if you type man unix in your terminal, you should land on an ancient man page: UNIX(7) Linux Programmer's Manual UNIX(7) NAME unix - sockets for local interprocess communication that explains how sockets are declared in C in the kernel, how they are created with the AF_UNIX system call, and many more thing that go far beyond my limited understanding. Creating a socket is not as easy as creating just any file, using, say, touch. They are tools available in the command line, but most of the time, sockets are created and used by processes, not by users. Looking up how to create one will land you on a tutorial in C, or in python. So let’s see how to do it in Rust. Make a socket server in Rust The Rust standard library has a unix module that contains modules to interact with unix processes, unix files, and so on. Within this unix module, we want to look at the net module, because unix sockets are used to do networking between processes. The std::os::unix::net module contains, among other things: UnixListener UnixStream Both those entities are unsafe wrappers of the libc library to perform the very same unix system calls you would write in C. They both wrap a unix file descriptor, but they are distinct in order to separate higher-level concerns. UnixListener is used to create sockets, UnixStream is there to read from and write on them. Let’s use those. Install Rust and Cargo, Learn the basics of Rust, and then do: cargo new unix_sockets Add this to Cargo.toml (makes error propagation easier): # Cargo.toml anyhow = \"^1.0.42\" ","date":"2022-01-06","objectID":"/2022/whatsaunixsocket/:1:0","tags":null,"title":"Unix sockets, the basics in Rust","uri":"/2022/whatsaunixsocket/"},{"categories":null,"content":"Create a socket, server side In the src directory, create a bin directory, in which you will create a server.rs file. // src/bin/server.rs usestd::os::unix::net::{UnixListener,UnixStream};useanyhow::Context;fn main()-\u003e anyhow::Result\u003c()\u003e{letsocket_path=\"mysocket\";letunix_listener=UnixListener::bind(socket_path).context(\"Could not create the unix socket\")?;Ok(())} Then do cargo run --bin server Which should run smoothly, and then do ls -l in your directory, you should have a line like this: srwxr-xr-x 1 emmanuel users 0 Jan 7 13:08 mysocket The s stands for socket. Congratulations! Do one more cargo run --bin server and you have a neat, self-explanatory OS error: Error: Could not create the unix socket Caused by: Address already in use (os error 98) I guess we’ll have to destroy it and recreate it each time. rm mysocket ","date":"2022-01-06","objectID":"/2022/whatsaunixsocket/:2:0","tags":null,"title":"Unix sockets, the basics in Rust","uri":"/2022/whatsaunixsocket/"},{"categories":null,"content":"Waiting for connections, server side The UnixListener struct has an accept() method that waits for other processes to connect to the socket. Once a connections come, accept() returns a tuple containing a UnixStream and a SocketAddr. As mentioned above, UnixStream implements Read and Write. We will handle this stream to: read what another process would write on the socket write responses Complete the code: // src/bin/server.rs usestd::os::unix::net::{UnixListener,UnixStream};fn main()-\u003e anyhow::Result\u003c()\u003e{letsocket_path=\"mysocket\";letunix_listener=UnixListener::bind(socket_path).context(\"Could not create the unix socket\")?;loop{let(mutunix_stream,socket_address)=unix_listener.accept().context(\"Failed at accepting a connection on the unix listener\")?;handle_stream(unix_stream)?;}Ok(())}fn handle_stream(mutstream: UnixStream)-\u003e anyhow::Result\u003c()\u003e{// to be filled Ok(())} Remove the existing socket and run the code: rm mysocket cargo run --bin server it should hang. Perfect! The server is waiting for connections! ","date":"2022-01-06","objectID":"/2022/whatsaunixsocket/:3:0","tags":null,"title":"Unix sockets, the basics in Rust","uri":"/2022/whatsaunixsocket/"},{"categories":null,"content":"Connecting to the socket, client side The client process wants to connect to an existing socket, read an write from it. Next to server.rs, create the client.rs file. The client will merely consist of a UnixStream: // src/bin/client.rs usestd::os::unix::net::{UnixListener,UnixStream};useanyhow::Context;fn main()-\u003e anyhow::Result\u003c()\u003e{letsocket_path=\"mysocket\";letmutunix_stream=UnixStream::connect(socket_path).context(\"Could not create stream\")?;Ok(()) ","date":"2022-01-06","objectID":"/2022/whatsaunixsocket/:4:0","tags":null,"title":"Unix sockets, the basics in Rust","uri":"/2022/whatsaunixsocket/"},{"categories":null,"content":"Writing onto the socket, client side We need to import the Read and Write traits, and now we can write onto the stream. Complete the code: // src/bin/client.rs usestd::io::{Read,Write};usestd::os::unix::net::{UnixListener,UnixStream};useanyhow::Context;fn main()-\u003e anyhow::Result\u003c()\u003e{letsocket_path=\"mysocket\";letmutunix_stream=UnixStream::connect(socket_path).context(\"Could not create stream\")?;unix_stream.write(b\"Hello?\")// we write bytes \u0026[u8] .context(\"Failed at writing onto the unix stream\")?;Ok(())} ","date":"2022-01-06","objectID":"/2022/whatsaunixsocket/:5:0","tags":null,"title":"Unix sockets, the basics in Rust","uri":"/2022/whatsaunixsocket/"},{"categories":null,"content":"Reading from the socket, server side Be sure to import Read and Write in server.rs: // src/bin/server.rs usestd::io::{Read,Write}; Now let’s fill the handle_stream function with ordinary read logic: // src/bin/server.rs fn handle_stream(mutstream: UnixStream)-\u003e anyhow::Result\u003c()\u003e{letmutmessage=String::new();stream.read_to_string(\u0026mutmessage).context(\"Failed at reading the unix stream\")?;println!(\"{}\",message);Ok(())} ","date":"2022-01-06","objectID":"/2022/whatsaunixsocket/:6:0","tags":null,"title":"Unix sockets, the basics in Rust","uri":"/2022/whatsaunixsocket/"},{"categories":null,"content":"Launch the whole thing! Make sure you have the server running in a terminal: rm mysocket cargo run --bin server And in a separate terminal, run the client: cargo run --bin client If all is well, the hello message should display on the server side. ","date":"2022-01-06","objectID":"/2022/whatsaunixsocket/:6:1","tags":null,"title":"Unix sockets, the basics in Rust","uri":"/2022/whatsaunixsocket/"},{"categories":null,"content":"The associated repository This tutorial comes with a github repository with a little custom-made socket library that does the automatic deletion and some more things like setting permissions. ","date":"2022-01-06","objectID":"/2022/whatsaunixsocket/:7:0","tags":null,"title":"Unix sockets, the basics in Rust","uri":"/2022/whatsaunixsocket/"},{"categories":null,"content":"This is my very first blog post to test out the Hugo framework. ","date":"2022-01-06","objectID":"/2022/helloworld/:0:0","tags":null,"title":"Hello World!","uri":"/2022/helloworld/"},{"categories":null,"content":"About myself My name is Emmanuel Bosquet aka Keksoj (=cookies in esperanto). I am an apprentice at Clever Cloud, hired to write some Rust. I am currently working on our reverse proxy written in Rust, Sōzu. A definite part of coding, in my opinion, is to write documentation. Readmes are my creed, markdown is my holy sword. I am embarked on a journey to make code ever more clear and readable, so that even a jerk like me can understand it. Aside from programming, I love languages (especially german) and playing guitar. ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"}]