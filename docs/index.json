[{"categories":null,"content":"Are you like me? Do you hate WYSIWYG document editors like Word, Page, or LibreOffice Writer? Are you more of a markdown person? Do you like text-based projects? Being a linux hardcore freak (or a wanabee linux hardcore freak), are you unafraid of the command line? Well I’ve got just the workflow for you : Write in markdown Generate a PDF with black magic Conquer the world Let’s dive in this together, in a drunken and self-deprecating mindset, otherwise it won’t be fun. ","date":"2022-02-17","objectID":"/2022/awesome_pdf_with_eisvogel/:0:0","tags":null,"title":"How to make awesome PDFs with markdown using Eisvogel","uri":"/2022/awesome_pdf_with_eisvogel/"},{"categories":null,"content":"Install Pandoc Pandoc is a crazy swiss-army knife haskell-written library that converts any markup-formatted document into another markup-formatted document. Pandoc converts html into json, man pages into html, epubs into docx, csv into dokuwiki, aaaaannnd markdown into PDF ! Install pandoc using your favorite package manager, on ubuntu or anything debian-based, on arch linux with the pandoc package, on macOS if you’re brave. According to some legends, you can even install it on windows. But that’s just the easy part. ","date":"2022-02-17","objectID":"/2022/awesome_pdf_with_eisvogel/:1:0","tags":null,"title":"How to make awesome PDFs with markdown using Eisvogel","uri":"/2022/awesome_pdf_with_eisvogel/"},{"categories":null,"content":"Install LaTeX and join the real cult Enter LaTeX, one of the oldest peaces of software still in use today. LaTeX started a bit like the GNU project. Some nitpicking bloke with too many free time on his hands and a lot of brain cells to burn decided that his book was not properly typeset. Yes, a guy actually complained about spacing between letters, margins around text, that kind of thing ordinary folks never worry about. So this Donald (yes, that’s his name, Donald Knuth) did what every (in)sane computer freak does: he went on to invent his own thing to solve his problem. His typesetting system is called TeX, pronounced “tek”, and went on to be wrapped and renamed and repackaged in an obscure way only encyclopedias and annoying know-it-alls understand. What we talk about now is LaTeX, but you have to pronounce it “latek” or you can’t be part of the gang. We’re in the freak zone. LaTeX is the king of markup languages, theoretically it is even turing-compatible, with if statements and whatnot. LaTeX is the assembly of document composing. LaTeX is the language of the gods. One example. This latex-written formula: s_N = \\sqrt{\\frac{1}{N} \\sum_{i=1}^N \\left(x_i - \\bar{x}\\right)^2}. becomes You can’t really beat that. We will need LaTeX. There’s no way around that if we want to brag in the classroom and impress… no one actually. No one will care. But let’s do it anyway. ","date":"2022-02-17","objectID":"/2022/awesome_pdf_with_eisvogel/:2:0","tags":null,"title":"How to make awesome PDFs with markdown using Eisvogel","uri":"/2022/awesome_pdf_with_eisvogel/"},{"categories":null,"content":"Installing LaTeX, or how to download way too heavy packages There’s no easy way around this. Tex and LaTeX are heavy. For Arch Linux fans: sudo pacman -S texlive-most ubuntu instructions Chances are, those command won’t work and you’ll end up searching the internet like a lost soul, deseperate for a way to understand how any of this is supposed to work. As a rule of thumb, install anything that ends with ex, be it pdflatex or xelatex or texlive and so on. You should get around 5 GB of packages to install. Yes. I told you we’re in the freak zone. What pandoc does is black magic Please play along or it won’t stick in your brain. Open this terminal and retype these commands. Copy-pasting is for the weak. ","date":"2022-02-17","objectID":"/2022/awesome_pdf_with_eisvogel/:2:1","tags":null,"title":"How to make awesome PDFs with markdown using Eisvogel","uri":"/2022/awesome_pdf_with_eisvogel/"},{"categories":null,"content":"Write in markdown Start a new project, shoot a markdown-written readme. mkdir my_awesome_pdf_project cd my_awesome_pdf_project touch README.md Write in README.md: # My awesome PDF project This simple readme shall become a PDF, or my name is not And then customize it with your name: echo \"$USER.\" \u003e\u003e README.md ","date":"2022-02-17","objectID":"/2022/awesome_pdf_with_eisvogel/:3:0","tags":null,"title":"How to make awesome PDFs with markdown using Eisvogel","uri":"/2022/awesome_pdf_with_eisvogel/"},{"categories":null,"content":"Get started with pandoc To gain a good understanding of how pandoc works, let’s convert this markdown to HTML. This will help understand how pandoc works. Everyone knows some HTML, even my 4 year-old nephew. You won’t have any excuse. We will: ask pandoc to take README.md as an input churn out a README.html file as an output. Type after me: pandoc README.md --output README.html --standalone Don’t mind the text warnings. Open the html file firefox README.html or if you will chrome README.html or safari, or chromium. You get the idea. Here’s how the HTML displays in the browser: What happened is, pandoc went through README.md, converted markdown markup into HTML markup. # became \u003ch1\u003e, etc., and voilà! (it wrote some more stuff on top of that, we’ll get to it) That’s pretty neat, but how about actual PDFs? ","date":"2022-02-17","objectID":"/2022/awesome_pdf_with_eisvogel/:4:0","tags":null,"title":"How to make awesome PDFs with markdown using Eisvogel","uri":"/2022/awesome_pdf_with_eisvogel/"},{"categories":null,"content":"How pandoc converts markdown to PDF “I see were you’re going, Emmanuel. I just need to type pandoc README.md -o README.pdf and I will have my PDF”. Well, yes, but also, no. You may succeed at first and be joyful. And you may just as well witness your enthusiasm crash splendidly, like a wave on the solid rock of reality. If you think this whole markdown-to-html stuff was easy and you wish for some more serious headache, you’re about to be served. Let’s go slowly about it. I have gained this knowledge with sweat and tears, it must be passed on. If you want to do it the easy way, you have to understand how it is done the hard way. ","date":"2022-02-17","objectID":"/2022/awesome_pdf_with_eisvogel/:5:0","tags":null,"title":"How to make awesome PDFs with markdown using Eisvogel","uri":"/2022/awesome_pdf_with_eisvogel/"},{"categories":null,"content":"From markdown to LaTeX Please type: pandoc README.md -o README.tex and have a look at README.tex: \\hypertarget{my-awesome-pdf-project} \\section{My awesome PDF project}\\label{my-awesome-pdf-project}} This simple readme shall become a PDF, or my name is not emmanuel. This is what LaTeX markup looks like. A bit verbose, but it looks serious. However, if you are even remotely familiar with LaTeX, you’ll notice some important markup is missing, like the very important \\documentclass line that basically says: “This document is a book / a memoire / an article, please typeset it accordingly”. If you’re clever enough, you’ll have the intuition of typing instead: pandoc README.md -o README.tex --standalone And boom ! Your README.tex looks a whole lot different now, with a \\documentClass{article} and a lot of \\usepackage statements and so on. That will make a neat PDF later on. ","date":"2022-02-17","objectID":"/2022/awesome_pdf_with_eisvogel/:5:1","tags":null,"title":"How to make awesome PDFs with markdown using Eisvogel","uri":"/2022/awesome_pdf_with_eisvogel/"},{"categories":null,"content":"Pandoc uses templates What happened here? Well, the mission of pandoc is to convert from one markup to another. A markdown’s *word* becomes an HTML \u003cem\u003eword\u003c/em\u003e becomes a TeX \\emph{word}. Pretty straightforward. But when dealing with complex document formats like HTML or LaTeX, we need a bunch of lines that say \u003cDOCTYPE html\u003e or \\documentClass{article}, and give precisions about the fonts used, the CSS or JavaScript files attached (in case of HTML) or the font size, the page format, the indentation of paragraphs (in case of LaTeX). So pandoc has this --standalone flag that summons default values. In the pandoc world, these defaults are stored in templates. Have a look at the HTML default template by doing: pandoc -D html You should recognize a lot of things. Head, meta, style, body… within some weird dollar-sign-surrounded if statements. This is pandoc’s own way of generating boiler-plate HTML headers. Same if you do: pandoc -D latex You will get a much more frightening blurb of interwoven LaTeX and pandoc-specific syntax. Please know that this exists, and that it is used when converting markdown to LaTeX with the --standalone flag. Please type this command if you haven’t yet: pandoc README.md -o README.tex --standalone and have a longer, curious look at the generated README.tex. ","date":"2022-02-17","objectID":"/2022/awesome_pdf_with_eisvogel/:5:2","tags":null,"title":"How to make awesome PDFs with markdown using Eisvogel","uri":"/2022/awesome_pdf_with_eisvogel/"},{"categories":null,"content":"From LaTeX to PDF From here on I’m not a specialist. The world of LaTeX is weird and intricate, full of weird and intricate history, populated by weird and intricate people (gosh, I am becoming one of them). The learning curve is hard and I feel like an impostor even writing about it. Be kind with yourself. If anything fails, skip this paragraph and go on with the tutorial. Let’s make an actual PDF. Try those commands randomly untif one of them work: latex README.tex xelatex README.tex pdflatex README.tex Those are all PDF engines. If the gods are on your side, one of those commands won’t fail and produce a README.pdf. Look it up. Admire it. Be proud of yourself. ","date":"2022-02-17","objectID":"/2022/awesome_pdf_with_eisvogel/:5:3","tags":null,"title":"How to make awesome PDFs with markdown using Eisvogel","uri":"/2022/awesome_pdf_with_eisvogel/"},{"categories":null,"content":"To sum up what pandoc does When you type pandoc README.md -o README.pdf, pandoc does those things: Convert the markdown markup to LaTeX markup Summon a default template to create LaTeX-specific statements like \\documentClass Merge everything in a neat .tex document Invoke a PDF engine necromant, to raise the .tex file from the dead realm of text onto the battlefield of our paper-dominated world. Make it easy please I have told you what I have learned. And for a while, what I have done was this: Write in markdown Store the default pandoc template within a template.tex file Edit template.tex to attain desired margins, fonts, etc (difficult) Do everything detailed above, in a bash script, plus the pandoc option: --template=templatex.tex This was great for learning purposes, but I now deserve simplicity, and so do you, dear reader. Let us discover Eisvogel. It boils down to replacing the default template used by pandoc when creating .tex files. ","date":"2022-02-17","objectID":"/2022/awesome_pdf_with_eisvogel/:5:4","tags":null,"title":"How to make awesome PDFs with markdown using Eisvogel","uri":"/2022/awesome_pdf_with_eisvogel/"},{"categories":null,"content":"Step by step Create another new project folder called use_eisvogel. mkdir use_eisvogel cd use_eisvogel Copy-paste the eisvogel.tex template from the official repository into you project folder. wget https://raw.githubusercontent.com/Wandmalfarbe/pandoc-latex-template/master/eisvogel.tex (or with curl if you prefer) curl https://raw.githubusercontent.com/Wandmalfarbe/pandoc-latex-template/master/eisvogel.tex \u003e eisvogel.tex Create a document.md, in which you will write: --- title: \"My awesome PDF\" subtitle: \"I kept retyping commands and it kept working\" author: \"Me, Myself and I\" geometry: margin=2cm titlepage: true --- # First chapter Once upon a time, LaTeX was made, and it was good. Then Microsoft Word was invented, and it was widely regarded as a bad move. ## Some section | column | colunn 2 | | ------ | -------- | | row | data | | what | ever | # Second chapter Here is some code: ```rust fn main(){println!(\"Hello world!\");}``` Create a bash script, make it executable: touch build.sh chmod +x build.sh Write in it: #!/usr/bin/env bash pandoc document.md \\ -o document.pdf \\ --template eisvogel.tex \\ --listings Execute the script (make sure you made it executable): ./build.sh If all went smooth, you should have a nice document.pdf. ","date":"2022-02-17","objectID":"/2022/awesome_pdf_with_eisvogel/:6:0","tags":null,"title":"How to make awesome PDFs with markdown using Eisvogel","uri":"/2022/awesome_pdf_with_eisvogel/"},{"categories":null,"content":"Go on your own journey The Eisvogel repository is full of examples and of easy-to-use variables to play around. You’re on your own now. Coding is hard, do only what you enjoy. Be kind to yourself. ","date":"2022-02-17","objectID":"/2022/awesome_pdf_with_eisvogel/:7:0","tags":null,"title":"How to make awesome PDFs with markdown using Eisvogel","uri":"/2022/awesome_pdf_with_eisvogel/"},{"categories":null,"content":"I found myself wondering about unix sockets while working on Sōzu, a reverse proxy written in Rust. A bunch of Sōzu issues led me to dig into Sōzu channels, which themselves make use of Metal I/O ’s implementation of unix sockets. Here are the questions, summed up: what are unix sockets? how can we create them in Rust? how do we use them to stream data? So here we go. ","date":"2022-01-06","objectID":"/2022/whatsaunixsocket/:0:0","tags":null,"title":"Unix sockets, the basics in Rust","uri":"/2022/whatsaunixsocket/"},{"categories":null,"content":"What is a unix socket? It is not a web socket like 127.0.0.1:8080. You may have heard that in unix, everything is a file. Unix sockets seem to be a good example of this principle. They are empty files of sorts, only there to be written to, and read from. Sockets are a core feature of unix. In fact, if you type man unix in your terminal, you should land on an ancient man page: UNIX(7) Linux Programmer's Manual UNIX(7) NAME unix - sockets for local interprocess communication that explains how sockets are declared in C in the kernel, how they are created with the AF_UNIX system call, and many more thing that go far beyond my limited understanding. Creating a socket is not as easy as creating just any file, using, say, touch. They are tools available in the command line, but most of the time, sockets are created and used by processes, not by users. Looking up how to create one will land you on a tutorial in C, or in python. So let’s see how to do it in Rust. Make a socket server in Rust The Rust standard library has a std::os::unix module to interact with unix processes, unix files, and so on. Within it, we want to look at the net module, named that way because unix sockets are used to do networking between processes. The std::os::unix::net module contains, among other things: UnixListener UnixStream Both those entities are unsafe wrappers of the libc library to perform the very same unix system calls you would write in C. They both wrap a unix file descriptor, but they are distinct in order to separate higher-level concerns. UnixListener is used to create sockets, (libc::bind() and libc::listen()) UnixStream is there to connect to a socket (libc::connect()), to read from it and write on it. Let’s use those. Install Rust and Cargo, Learn the basics of Rust, and then do: cargo new unix_sockets Add this to Cargo.toml (makes error propagation easier): # Cargo.toml anyhow = \"^1.0.42\" ","date":"2022-01-06","objectID":"/2022/whatsaunixsocket/:1:0","tags":null,"title":"Unix sockets, the basics in Rust","uri":"/2022/whatsaunixsocket/"},{"categories":null,"content":"Create a socket, server side In the src directory, create a bin directory, in which you will create a server.rs file. // src/bin/server.rs usestd::os::unix::net::{UnixListener,UnixStream};useanyhow::Context;fn main()-\u003e anyhow::Result\u003c()\u003e{letsocket_path=\"mysocket\";letunix_listener=UnixListener::bind(socket_path).context(\"Could not create the unix socket\")?;Ok(())} Then do cargo run --bin server Which should run smoothly, and then do ls -l in your directory, you should have a line like this: srwxr-xr-x 1 emmanuel users 0 Jan 7 13:08 mysocket The s stands for socket. Congratulations! Do one more cargo run --bin server and you have a neat, self-explanatory OS error: Error: Could not create the unix socket Caused by: Address already in use (os error 98) I guess we’ll have to destroy it and recreate it each time. // src/bin/server.rs usestd::os::unix::net::{UnixListener,UnixStream};useanyhow::Context;fn main()-\u003e anyhow::Result\u003c()\u003e{letsocket_path=\"mysocket\";// copy-paste this and don't think about it anymore // it will be hidden from there on ifstd::fs::metadata(socket_path).is_ok(){println!(\"A socket is already present. Deleting...\");std::fs::remove_file(socket_path).with_context(||{format!(\"could not delete previous socket at {:?}\",socket_path)})?;}letunix_listener=UnixListener::bind(socket_path).context(\"Could not create the unix socket\")?;Ok(())} ","date":"2022-01-06","objectID":"/2022/whatsaunixsocket/:2:0","tags":null,"title":"Unix sockets, the basics in Rust","uri":"/2022/whatsaunixsocket/"},{"categories":null,"content":"Waiting for connections, server side The UnixListener struct has an accept() method that waits for other processes to connect to the socket. Once a connections comes, accept() returns a tuple containing a UnixStream and a SocketAddr. As mentioned above, UnixStream implements Read and Write. We will handle this stream to: read what another process will send through the socket write responses on the socket Add the loop and the handle_stream function to the server code: // src/bin/server.rs usestd::os::unix::net::{UnixListener,UnixStream};fn main()-\u003e anyhow::Result\u003c()\u003e{letsocket_path=\"mysocket\";letunix_listener=UnixListener::bind(socket_path).context(\"Could not create the unix socket\")?;// put the server logic in a loop to accept several connections loop{let(mutunix_stream,socket_address)=unix_listener.accept().context(\"Failed at accepting a connection on the unix listener\")?;handle_stream(unix_stream)?;}Ok(())}fn handle_stream(mutstream: UnixStream)-\u003e anyhow::Result\u003c()\u003e{// to be filled Ok(())} Remove the existing socket and run the code: cargo run --bin server it should hang. Perfect! The server is waiting for connections! ","date":"2022-01-06","objectID":"/2022/whatsaunixsocket/:3:0","tags":null,"title":"Unix sockets, the basics in Rust","uri":"/2022/whatsaunixsocket/"},{"categories":null,"content":"Connecting to the socket, client side The client process wants to connect to an existing socket, read an write from it. Next to server.rs, create the client.rs file. The client will merely consist of a UnixStream: // src/bin/client.rs usestd::os::unix::net::{UnixListener,UnixStream};useanyhow::Context;fn main()-\u003e anyhow::Result\u003c()\u003e{letsocket_path=\"mysocket\";letmutunix_stream=UnixStream::connect(socket_path).context(\"Could not create stream\")?;Ok(()) ","date":"2022-01-06","objectID":"/2022/whatsaunixsocket/:4:0","tags":null,"title":"Unix sockets, the basics in Rust","uri":"/2022/whatsaunixsocket/"},{"categories":null,"content":"Writing on the socket, client side We need to import the Read and Write traits. // src/bin/client.rs usestd::io::{Read,Write}; And now we can write onto the stream. Below the unix_stream declaration, add the write logic: unix_stream.write(b\"Hello?\")// we write bytes, \u0026[u8] .context(\"Failed at writing onto the unix stream\")?; ","date":"2022-01-06","objectID":"/2022/whatsaunixsocket/:5:0","tags":null,"title":"Unix sockets, the basics in Rust","uri":"/2022/whatsaunixsocket/"},{"categories":null,"content":"Reading from the socket, server side Be sure to import Read and Write in server.rs: // src/bin/server.rs usestd::io::{Read,Write}; Now let’s fill the handle_stream function with ordinary read logic: // src/bin/server.rs fn handle_stream(mutunix_stream: UnixStream)-\u003e anyhow::Result\u003c()\u003e{letmutmessage=String::new();unix_stream.read_to_string(\u0026mutmessage).context(\"Failed at reading the unix stream\")?;println!(\"{}\",message);Ok(())} ","date":"2022-01-06","objectID":"/2022/whatsaunixsocket/:6:0","tags":null,"title":"Unix sockets, the basics in Rust","uri":"/2022/whatsaunixsocket/"},{"categories":null,"content":"Launch the whole thing! Make sure you have the server running in a terminal: cargo run --bin server And in a separate terminal, run the client: cargo run --bin client If all is well, the hello message should display on the server side. ","date":"2022-01-06","objectID":"/2022/whatsaunixsocket/:6:1","tags":null,"title":"Unix sockets, the basics in Rust","uri":"/2022/whatsaunixsocket/"},{"categories":null,"content":"Respond to a message, server side Let’s answer something every time the server receives anything. // src/bin/server.rs fn handle_stream(mutunix_stream: UnixStream)-\u003e anyhow::Result\u003c()\u003e{letmutmessage=String::new();unix_stream.read_to_string(\u0026mutmessage).context(\"Failed at reading the unix stream\")?;println!(\"We received this message: {}\\nReplying...\",message);unix_stream.write(b\"I hear you!\").context(\"Failed at writing onto the unix stream\")?;Ok(())} ","date":"2022-01-06","objectID":"/2022/whatsaunixsocket/:7:0","tags":null,"title":"Unix sockets, the basics in Rust","uri":"/2022/whatsaunixsocket/"},{"categories":null,"content":"Listen to responses, client side Introducing the same reading logic we used on the server will not work. Why? After writing on a stream, we need to shut down the writing, if we want to read from it. Let’s segregate the write and read logic into distinct functions. Oh, and we pass mutable references (\u0026mut) of the unix stream to the function, because… Rust. Don’t worry about it. // src/bin/client.rs usestd::io::{Read,Write};usestd::os::unix::net::{UnixListener,UnixStream};useanyhow::Context;fn main()-\u003e anyhow::Result\u003c()\u003e{letsocket_path=\"mysocket\";letmutunix_stream=UnixStream::connect(socket_path).context(\"Could not create stream\")?;write_request_and_shutdown(\u0026mutunix_stream)?;read_from_stream(\u0026mutunix_stream)?;Ok(())} The shutdown() method takes a Shutdown enum we would otherwise use on TCP streams. Write below the main function: fn write_request_and_shutdown(unix_stream: \u0026mutUnixStream)-\u003e anyhow::Result\u003c()\u003e{unix_stream.write(b\"Hello?\").context(\"Failed at writing onto the unix stream\")?;println!(\"We sent a request\");println!(\"Shutting down writing on the stream, waiting for response...\");unix_stream.shutdown(std::net::Shutdown::Write).context(\"Could not shutdown writing on the stream\")?;Ok(())} The stream is now clean to be read from. fn read_from_stream(unix_stream: \u0026mutUnixStream)-\u003e anyhow::Result\u003c()\u003e{letmutresponse=String::new();unix_stream.read_to_string(\u0026mutresponse).context(\"Failed at reading the unix stream\")?;println!(\"We received this response: {}\",response);Ok(())} ","date":"2022-01-06","objectID":"/2022/whatsaunixsocket/:8:0","tags":null,"title":"Unix sockets, the basics in Rust","uri":"/2022/whatsaunixsocket/"},{"categories":null,"content":"Launch the whole thing, again! Have the server running in a terminal: cargo run --bin server And in a separate terminal, run the client: cargo run --bin client If all is well, the hello message should display on the server side the “I hear you” response should display on the client side You can run the client as many times as you want, since the server runs in a loop. ","date":"2022-01-06","objectID":"/2022/whatsaunixsocket/:8:1","tags":null,"title":"Unix sockets, the basics in Rust","uri":"/2022/whatsaunixsocket/"},{"categories":null,"content":"Browse the code This tutorial comes with a github repository that contains the above code. Feel free to write an issue for any comment, cricic or complaint you may have. Fork and do pull requests as you please. This blog post is a sum-up of what I learned trying to understand unix sockets while working on Sōzu. A more elaborate version of the code is available in this other repo, with additional features: a UnixListener-wrapping library with a glorious SocketBuilder helper (permissions! blocking/nonblocking!) a Message module with serializable Request and Response structs. The Response has a status that is either Ok, Error or Processing a client loop that continues reading the stream as long as responses come with a Processing status, to stops only at Ok or Error All this happened thanks to my employer, Clever Cloud, who allows me to learn my job in the best possible conditions. Much gratitude. ","date":"2022-01-06","objectID":"/2022/whatsaunixsocket/:9:0","tags":null,"title":"Unix sockets, the basics in Rust","uri":"/2022/whatsaunixsocket/"},{"categories":null,"content":"This is an answer to all those recruiters asking “How do you explain this gap in your resume?”. I couldn’t stand pretending to be a healthy human being, so here is the truth. (born 1986) 2004 - 2005, Caen, Normandy. First year of a Physics Measurements degree. Failed spectacularly. 2007-10 - 2007-12, Stuttgart, Germany. Wandering in Germany searching for a job. 2008-10 - 2009-03, Heidelberg, Germany. Learning japanese at the university hoping to work in Japan. Wow that went well. 2009-03 - 2009-10, Germany, Czech Republic. Back-packing speaking esperanto and wwoofing. That one was nice actually. 2009-10 - 2010-02, Calais, France. Bachelor degree of industrial engineering. Ended up crying, shaving my head and doing drugs. But hey I discovered Linux. 2010-10, Frankfurt. Searching for a job in Germany, ended in intense feelings of depression and worthlessness. 2011-01 - 2011-03, Israel \u0026 Berlin. Esperanto meetings, visiting Israel, hanging in Berlin and -surprise- doing drugs. 2015-01 - 2015-03, Caen, Normandy. Dropped out of university, searched for a job in an unrelated field, feeling miserable and inadequate. 2018-09, India. Visiting northern India and getting scammed of all my money. 2018-10, Köln, Germany. Trying to make a new life in Germany. Oh hi, worthlessness, I didn’t miss you. 2019-01 - 2020-07, Caen, Normandy. Learned programming on my own, living on unemployment benefits. ","date":"2021-11-30","objectID":"/2021/myresumebutitsonlythegaps/:0:0","tags":null,"title":"My resume but it's only the gaps","uri":"/2021/myresumebutitsonlythegaps/"},{"categories":null,"content":"Voici la conférence que j’ai animée au CaenCamp en octobre 2021, où je passe en revue les bases de Rust, au compilateur très pédagogique. En plus de la vidéo, retrouvez : Les slides en ligne Le dépôt github avec tous le code présenté, et plus encore ","date":"2021-10-28","objectID":"/2021/rustouleplaisirdecoder/:0:0","tags":null,"title":"Rust, ou le plaisir de coder","uri":"/2021/rustouleplaisirdecoder/"},{"categories":null,"content":"One day I understood I could write javascript the proper way : object-oriented with separate files with JSdocs types as far away from the HTML as possible AND have it work in the browser. So I ported my dear tetris logic I had written in Rust for the terminal into the browser, using canvas. Play it here. I’m afraid it only works on the desktop, and it may be buggy, but hey I made a tetris, how awesome is that? ","date":"2020-11-25","objectID":"/2020/tetrisinthebrowser/:0:0","tags":null,"title":"Tetris in the browser","uri":"/2020/tetrisinthebrowser/"},{"categories":null,"content":"About myself My name is Emmanuel Bosquet aka Keksoj (=cookies in esperanto). I am an apprentice at Clever Cloud, hired to write some Rust. I am currently working on our reverse proxy written in Rust, Sōzu. A definite part of coding, in my opinion, is to write documentation. Readmes are my creed, markdown is my holy sword. I am embarked on a journey to make code ever more clear and readable, so that even a jerk like me can understand it. Aside from programming, I love languages (especially german) and playing guitar. ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"}]